<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bubble Shooter Pro - Klasik Mod</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0; padding: 0; overflow: hidden;
            background-color: #c4b5fd; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        #main-layout {
            display: flex;
            width: 100vw;
            height: 100vh;
            align-items: center;
            justify-content: center;
            padding: 10px;
            gap: 20px;
        }
        #game-area {
            position: relative;
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            overflow: hidden;
            flex-grow: 1;
            max-width: 800px;
        }
        canvas {
            display: block;
            background-color: #f5f3ff;
            cursor: crosshair;
            width: 100%;
            height: auto;
        }
        #sidebar {
            width: 220px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 40;
        }
        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        .icon-btn {
            width: 55px;
            height: 55px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }
        .icon-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0,0,0,0.15); }
        .icon-btn:active { transform: scale(0.9); }
        
        .overlay {
            position: absolute; inset: 0;
            background: rgba(139, 92, 246, 0.98);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 50; color: white; border-radius: 20px;
            text-align: center;
            padding: 20px;
        }

        .theme-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
            width: 100%;
            max-width: 500px;
        }
        .theme-card {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .theme-card:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-5px);
            border-color: white;
        }
        .theme-preview {
            font-size: 40px;
            filter: drop-shadow(0 4px 4px rgba(0,0,0,0.2));
        }

        /* Ceza Toplarƒ± Stili */
        .penalty-container {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }
        .penalty-bubble {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #cbd5e1;
            border: 1px solid #94a3b8;
            transition: background 0.3s;
        }
        .penalty-bubble.active {
            background: #64748b;
        }
    </style>
</head>
<body oncontextmenu="return false;">

<div id="main-layout">
    <div id="game-area">
        <canvas id="gameCanvas"></canvas>
        
        <div id="menu-overlay" class="overlay">
            <h1 class="text-5xl font-black mb-2 italic">BUBBLE</h1>
            <h2 class="text-2xl font-light mb-8">TEMA SE√á VE BA≈ûLA</h2>
            
            <div class="theme-grid">
                <div class="theme-card" onclick="setTheme('default')">
                    <div class="theme-preview">üî¥</div>
                    <span class="font-bold text-sm">KLASƒ∞K</span>
                </div>
                <div class="theme-card" onclick="setTheme('animals')">
                    <div class="theme-preview">üêº</div>
                    <span class="font-bold text-sm">HAYVANLAR</span>
                </div>
                <div class="theme-card" onclick="setTheme('candy')">
                    <div class="theme-preview">üç≠</div>
                    <span class="font-bold text-sm">≈ûEKERLER</span>
                </div>
            </div>

            <button class="mt-10 bg-white text-violet-600 px-12 py-4 rounded-full font-bold text-2xl shadow-xl hover:scale-105 transition-transform" onclick="startGame()">OYNAT</button>
        </div>

        <div id="game-over-overlay" class="overlay hidden">
            <h2 class="text-6xl font-black mb-4 text-red-200">OYUN Bƒ∞TTƒ∞</h2>
            <div class="text-3xl mb-8">Toplam Skor: <span id="final-score" class="font-black">0</span></div>
            <button class="bg-white text-violet-600 px-10 py-4 rounded-full font-bold text-xl shadow-lg" onclick="startGame()">TEKRAR DENE</button>
        </div>
    </div>

    <div id="sidebar">
        <div class="flex justify-around mb-2">
            <button class="icon-btn" title="Yeniden Ba≈ülat" onclick="resetGame()">üîÑ</button>
            <button id="mute-toggle" class="icon-btn" title="Ses A√ß/Kapat" onclick="toggleMute()">üîä</button>
        </div>

        <div class="stat-card">
            <span class="text-yellow-500 text-3xl mb-1">üèÜ</span>
            <span class="text-xs text-gray-400 font-bold tracking-widest">EN Y√úKSEK</span>
            <span class="text-2xl font-black text-gray-700" id="high-score">0</span>
        </div>

        <div class="stat-card">
            <span class="text-blue-500 text-3xl mb-1">üéØ</span>
            <span class="text-xs text-gray-400 font-bold tracking-widest">PUAN</span>
            <span class="text-3xl font-black text-gray-800" id="current-score">0</span>
        </div>

        <!-- Ceza G√∂stergesi Kartƒ± (Sƒ±radaki kutusuyla birlikte g√∂r√ºn√ºr) -->
        <div id="penalty-card" class="stat-card hidden">
            <span class="text-xs text-gray-400 font-bold tracking-widest uppercase">Ceza Haklarƒ±</span>
            <div class="penalty-container" id="penalty-bubbles"></div>
        </div>

        <div id="next-panel" class="stat-card hidden">
            <span class="text-xs text-gray-400 font-bold mb-3 tracking-widest uppercase">Sƒ±radaki</span>
            <div class="bg-violet-50 p-4 rounded-2xl">
                <canvas id="nextBubbleCanvas" width="60" height="60"></canvas>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * BUBBLE SHOOTER - FIXED PROGRESSION & CONNECTIVITY
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const nextCanvas = document.getElementById('nextBubbleCanvas');
const nextCtx = nextCanvas.getContext('2d');

const ROWS = 20;
const COLS = 16; 
const AUTO_DROP_SECONDS = 25; 
const MAX_MISSES = 5; // Ka√ß hatalƒ± atƒ±≈üta satƒ±r iner

const STATES = { MENU: 0, PLAYING: 1, GAMEOVER: 2 };
let gameState = STATES.MENU;

let score = 0;
let highScore = localStorage.getItem('bs_high_score_v2') || 0;
let bubbleRadius = 0;
let rowHeight = 0;
let lastDropTime = 0;
let shotCounter = MAX_MISSES;
let currentTheme = 'default';
let isMuted = false;

// SES Y√ñNETƒ∞Mƒ∞
const audioLibrary = {
    shoot: new Audio('https://assets.mixkit.co/active_storage/sfx/2571/2571-preview.mp3'),
    win: new Audio('https://assets.mixkit.co/active_storage/sfx/1435/1435-preview.mp3'),
    gameOver: new Audio('https://assets.mixkit.co/active_storage/sfx/2522/2522-preview.mp3'),
    bgm: new Audio('https://assets.mixkit.co/active_storage/sfx/123/123-preview.mp3'),
    pop_default: new Audio('https://assets.mixkit.co/active_storage/sfx/615/615-preview.mp3'),
    pop_animals: new Audio('https://assets.mixkit.co/active_storage/sfx/2513/2513-preview.mp3'),
    pop_candy: new Audio('https://assets.mixkit.co/active_storage/sfx/584/584-preview.mp3')
};

audioLibrary.bgm.loop = true;
audioLibrary.bgm.volume = 0.2;

function playSound(soundKey) {
    if (isMuted) return;
    const sound = audioLibrary[soundKey];
    if (sound) {
        sound.currentTime = 0;
        sound.play().catch(e => {});
    }
}

function toggleMute() {
    isMuted = !isMuted;
    document.getElementById('mute-toggle').innerText = isMuted ? 'üîá' : 'üîä';
    if (isMuted) audioLibrary.bgm.pause();
    else if (gameState === STATES.PLAYING) audioLibrary.bgm.play();
}

const THEMES = {
    default: { icons: null, popSound: 'pop_default', colors: [
        { name: 'red', gradient: ['#FF5F6D', '#B91C1C'] }, { name: 'blue', gradient: ['#38bdf8', '#1e40af'] },
        { name: 'green', gradient: ['#4ade80', '#166534'] }, { name: 'yellow', gradient: ['#fde047', '#a16207'] },
        { name: 'purple', gradient: ['#c084fc', '#6b21a8'] }, { name: 'cyan', gradient: ['#22d3ee', '#0e7490'] },
        { name: 'orange', gradient: ['#fb923c', '#9a3412'] }
    ]},
    animals: { icons: ['üêª', 'üêº', 'üêØ', 'ü¶Å', 'üê∏', 'üêµ', 'üê∞'], popSound: 'pop_animals', colors: [
        { name: 'brown', gradient: ['#A8A29E', '#78350F'] }, { name: 'white', gradient: ['#F8FAFC', '#94A3B8'] },
        { name: 'orange', gradient: ['#FDBA74', '#C2410C'] }, { name: 'yellow', gradient: ['#FEF08A', '#A16207'] },
        { name: 'green', gradient: ['#86EFAC', '#15803D'] }, { name: 'gray', gradient: ['#CBD5E1', '#475569'] },
        { name: 'pink', gradient: ['#F9A8D4', '#BE185D'] }
    ]},
    candy: { icons: ['üç≠', 'üç¨', 'üç©', 'üßÅ', 'üç¶', 'üç™', 'üç´'], popSound: 'pop_candy', colors: [
        { name: 'pink', gradient: ['#FBCFE8', '#DB2777'] }, { name: 'blue', gradient: ['#BFDBFE', '#2563EB'] },
        { name: 'purple', gradient: ['#E9D5FF', '#9333EA'] }, { name: 'cyan', gradient: ['#CFFAFE', '#0891B2'] },
        { name: 'mint', gradient: ['#D1FAE5', '#059669'] }, { name: 'cream', gradient: ['#FEF3C7', '#D97706'] },
        { name: 'red', gradient: ['#FECACA', '#DC2626'] }
    ]}
};

let grid = [];
let projectile = null;
let nextColorIndex = 0;
let mouse = { x: 0, y: 0 };
let popAnimations = [];

function setTheme(theme) {
    currentTheme = theme;
    const cards = document.querySelectorAll('.theme-card');
    cards.forEach(c => c.style.borderColor = 'rgba(255,255,255,0.2)');
    event.currentTarget.style.borderColor = 'white';
}

function resetGame() {
    audioLibrary.bgm.pause();
    document.getElementById('menu-overlay').classList.remove('hidden');
    document.getElementById('game-over-overlay').classList.add('hidden');
    document.getElementById('next-panel').classList.add('hidden');
    document.getElementById('penalty-card').classList.add('hidden');
    gameState = STATES.MENU;
}

function startGame() {
    gameState = STATES.PLAYING;
    score = 0;
    shotCounter = MAX_MISSES;
    lastDropTime = Date.now();
    document.getElementById('menu-overlay').classList.add('hidden');
    document.getElementById('game-over-overlay').classList.add('hidden');
    document.getElementById('high-score').innerText = highScore;
    document.getElementById('next-panel').classList.remove('hidden');
    document.getElementById('penalty-card').classList.remove('hidden');
    
    if (!isMuted) audioLibrary.bgm.play();
    
    resize();
    initGrid();
    nextColorIndex = Math.floor(Math.random() * THEMES[currentTheme].colors.length);
    createProjectile();
    updateUI();
}

function initGrid() {
    grid = [];
    const themeData = THEMES[currentTheme];
    for (let r = 0; r < ROWS; r++) {
        grid[r] = [];
        for (let c = 0; c < COLS; c++) {
            grid[r][c] = {
                active: r < 6,
                colorIndex: Math.floor(Math.random() * themeData.colors.length),
                r: r, c: c,
                isPopping: false
            };
        }
    }
}

function getBubbleCoords(r, c) {
    let x = c * bubbleRadius * 2 + bubbleRadius;
    if (r % 2 !== 0) x += bubbleRadius;
    let y = r * rowHeight + bubbleRadius;
    return { x, y };
}

function getNeighbors(r, c) {
    const n = [];
    const offset = (r % 2 === 0) ? 0 : 1;
    const dirs = [[0,-1],[0,1],[-1,-1+offset],[-1,offset],[1,-1+offset],[1,offset]];
    for (let [dr, dc] of dirs) {
        let nr = r + dr, nc = c + dc;
        if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) n.push(grid[nr][nc]);
    }
    return n;
}

function findMatches(r, c, color, matches = new Set()) {
    const key = `${r},${c}`;
    if (matches.has(key)) return matches;
    if (!grid[r][c].active || grid[r][c].colorIndex !== color || grid[r][c].isPopping) return matches;
    matches.add(key);
    getNeighbors(r, c).forEach(nb => findMatches(nb.r, nb.c, color, matches));
    return matches;
}

function dropDisconnected() {
    grid.forEach(row => row.forEach(b => b.connected = false));
    const queue = [];
    for (let c = 0; c < COLS; c++) {
        if (grid[0][c].active && !grid[0][c].isPopping) {
            grid[0][c].connected = true;
            queue.push(grid[0][c]);
        }
    }
    
    let head = 0;
    while(head < queue.length) {
        const curr = queue[head++];
        getNeighbors(curr.r, curr.c).forEach(nb => {
            if (nb.active && !nb.connected && !nb.isPopping) {
                nb.connected = true;
                queue.push(nb);
            }
        });
        // head++ kaldƒ±rƒ±ldƒ±, queue[head++] zaten doƒüru ilerliyor
    }
    
    let count = 0;
    grid.forEach(row => row.forEach(b => {
        if (b.active && !b.connected && !b.isPopping) { 
            startPopAnimation(b.r, b.c);
            count++; 
        }
    }));
    return count;
}

function startPopAnimation(r, c) {
    const b = grid[r][c];
    if (b.isPopping) return;
    b.isPopping = true;
    popAnimations.push({
        r: r, c: c,
        colorIndex: b.colorIndex,
        startTime: Date.now()
    });
    playSound(THEMES[currentTheme].popSound);
}

function resize() {
    const container = document.getElementById('game-area');
    canvas.width = container.clientWidth;
    canvas.height = window.innerHeight * 0.9;
    bubbleRadius = canvas.width / (COLS + 0.5) / 2;
    rowHeight = bubbleRadius * 1.732;
}

function updateUI() {
    document.getElementById('current-score').innerText = score;
    nextCtx.clearRect(0,0,60,60);
    drawBubbleOnCtx(nextCtx, 30, 30, nextColorIndex, 0.9);

    // Ceza G√∂stergesi
    const penaltyBox = document.getElementById('penalty-bubbles');
    penaltyBox.innerHTML = '';
    for(let i=0; i<MAX_MISSES; i++) {
        const bubble = document.createElement('div');
        bubble.className = 'penalty-bubble' + (i < shotCounter ? ' active' : '');
        penaltyBox.appendChild(bubble);
    }
}

function drawBubbleOnCtx(context, x, y, colorIndex, scale = 1, alpha = 1) {
    const themeData = THEMES[currentTheme];
    const color = themeData.colors[colorIndex];
    if (!color) return;
    const r = Math.max(0, bubbleRadius * scale);
    context.globalAlpha = alpha;
    const grad = context.createRadialGradient(x-r/3, y-r/3, r/10, x, y, r);
    grad.addColorStop(0, color.gradient[0]);
    grad.addColorStop(1, color.gradient[1]);
    context.fillStyle = grad;
    context.beginPath();
    context.arc(x, y, r, 0, Math.PI * 2);
    context.fill();
    if (themeData.icons) {
        context.font = `${r * 1.2}px Arial`;
        context.textAlign = 'center'; context.textBaseline = 'middle';
        context.fillText(themeData.icons[colorIndex], x, y + r*0.05);
    }
    context.fillStyle = 'rgba(255,255,255,0.2)';
    context.beginPath();
    context.arc(x-r/3, y-r/3, r/3.5, 0, Math.PI * 2);
    context.fill();
    context.globalAlpha = 1;
}

function drawAimingArrow(startX, startY, angle) {
    ctx.save();
    ctx.translate(startX, startY);
    ctx.rotate(angle);
    const arrowLen = 140;
    const grad = ctx.createLinearGradient(0, 0, arrowLen, 0);
    grad.addColorStop(0, 'rgba(139, 92, 246, 0.9)');
    grad.addColorStop(1, 'rgba(139, 92, 246, 0)');
    ctx.strokeStyle = grad; ctx.lineWidth = 6; ctx.lineCap = 'round';
    ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(arrowLen, 0); ctx.stroke();
    ctx.fillStyle = 'rgba(139, 92, 246, 0.9)';
    ctx.beginPath(); ctx.moveTo(arrowLen, 0); ctx.lineTo(arrowLen - 15, -8); ctx.lineTo(arrowLen - 15, 8); ctx.fill();
    ctx.restore();
}

function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (gameState === STATES.PLAYING) {
        const now = Date.now();
        // Zaman bazlƒ± d√º≈üme (Yedek mekanizma)
        if (now - lastDropTime >= AUTO_DROP_SECONDS * 1000) {
            pushGridDown();
            lastDropTime = now;
        }

        grid.forEach(row => row.forEach(b => {
            if (b.active && !b.isPopping) {
                const { x, y } = getBubbleCoords(b.r, b.c);
                drawBubbleOnCtx(ctx, x, y, b.colorIndex);
            }
        }));

        for (let i = popAnimations.length - 1; i >= 0; i--) {
            const anim = popAnimations[i];
            const elapsed = Date.now() - anim.startTime;
            const progress = elapsed / 400;
            if (progress >= 1) {
                grid[anim.r][anim.c].active = false;
                grid[anim.r][anim.c].isPopping = false;
                popAnimations.splice(i, 1);
            } else {
                const { x, y } = getBubbleCoords(anim.r, anim.c);
                drawBubbleOnCtx(ctx, x, y, anim.colorIndex, 1.2 * (1 - progress), 1 - progress);
            }
        }

        const startX = canvas.width / 2, startY = canvas.height - bubbleRadius - 30;
        const angle = Math.atan2(mouse.y - startY, mouse.x - startX);
        if (angle < 0 && !projectile.moving && !projectile.isSettling) drawAimingArrow(startX, startY, angle);

        if (projectile) {
            if (projectile.moving) {
                projectile.x += projectile.vx;
                projectile.y += projectile.vy;
                if (projectile.x < bubbleRadius || projectile.x > canvas.width - bubbleRadius) projectile.vx *= -1;
                checkCollision();
            } else if (projectile.isSettling) {
                const dx = projectile.targetX - projectile.x;
                const dy = projectile.targetY - projectile.y;
                projectile.x += dx * 0.15; projectile.y += dy * 0.15;
                if (Math.hypot(dx, dy) < 1) finalizeSettling();
            }
            drawBubbleOnCtx(ctx, projectile.x, projectile.y, projectile.colorIndex);
        }
    }
    requestAnimationFrame(render);
}

function checkCollision() {
    let hit = projectile.y <= bubbleRadius;
    if (!hit) {
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                if (grid[r][c].active && !grid[r][c].isPopping) {
                    const { x, y } = getBubbleCoords(r, c);
                    if (Math.hypot(projectile.x - x, projectile.y - y) < bubbleRadius * 1.5) { hit = true; break; }
                }
            }
            if (hit) break;
        }
    }
    if (hit) {
        projectile.moving = false;
        let r = Math.round((projectile.y - bubbleRadius) / rowHeight);
        let offsetX = (r % 2 !== 0) ? bubbleRadius : 0;
        let c = Math.max(0, Math.min(COLS-1, Math.round((projectile.x - bubbleRadius - offsetX) / (bubbleRadius * 2))));
        if (grid[r][c] && grid[r][c].active) {
            const neighbors = getNeighbors(r, c).filter(n => !n.active);
            if (neighbors.length > 0) {
                let best = neighbors[0], minDist = Infinity;
                neighbors.forEach(n => {
                    const coords = getBubbleCoords(n.r, n.c);
                    const d = Math.hypot(projectile.x - coords.x, projectile.y - coords.y);
                    if (d < minDist) { minDist = d; best = n; }
                }); r = best.r; c = best.c;
            }
        }
        const target = getBubbleCoords(r, c);
        projectile.targetX = target.x; projectile.targetY = target.y;
        projectile.targetR = r; projectile.targetC = c;
        projectile.isSettling = true;
    }
}

function finalizeSettling() {
    const r = projectile.targetR; const c = projectile.targetC;
    if (r >= ROWS - 2) { endGame(); return; }
    grid[r][c].active = true;
    grid[r][c].colorIndex = projectile.colorIndex;
    const matches = findMatches(r, c, grid[r][c].colorIndex);
    
    if (matches.size >= 3) {
        matches.forEach(k => { 
            const [rr, cc] = k.split(',').map(Number); 
            startPopAnimation(rr, cc);
        });
        score += matches.size * 10;
        setTimeout(() => {
            const dropped = dropDisconnected();
            if (dropped > 0) score += dropped * 20;
            updateUI();
        }, 100);
        // Ba≈üarƒ±lƒ± patlatmada ceza sayacƒ± dolmaz (veya klasik modda azalmaz)
    } else {
        // Hatalƒ± atƒ±≈üta ceza sayacƒ±nƒ± azalt
        shotCounter--;
        if (shotCounter <= 0) {
            pushGridDown();
            shotCounter = MAX_MISSES;
        }
    }
    
    updateUI();
    createProjectile();
    checkWinCondition();
}

function checkWinCondition() {
    const hasActive = grid.some(row => row.some(b => b.active));
    if (!hasActive) { playSound('win'); setTimeout(() => { resetGame(); }, 2000); }
}

function pushGridDown() {
    for (let r = ROWS - 1; r > 0; r--) {
        for (let c = 0; c < COLS; c++) {
            grid[r][c].active = grid[r-1][c].active;
            grid[r][c].colorIndex = grid[r-1][c].colorIndex;
        }
    }
    const themeData = THEMES[currentTheme];
    for (let c = 0; c < COLS; c++) {
        grid[0][c].active = true;
        grid[0][c].colorIndex = Math.floor(Math.random() * themeData.colors.length);
    }
    // Limit kontrol√º
    for (let c = 0; c < COLS; c++) if (grid[ROWS-3][c].active) endGame();
    updateUI();
}

function endGame() {
    gameState = STATES.GAMEOVER;
    audioLibrary.bgm.pause();
    playSound('gameOver');
    document.getElementById('game-over-overlay').classList.remove('hidden');
    document.getElementById('final-score').innerText = score;
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('bs_high_score_v2', highScore);
        document.getElementById('high-score').innerText = highScore;
    }
}

function createProjectile() {
    projectile = {
        x: canvas.width/2, y: canvas.height - bubbleRadius - 30,
        vx: 0, vy: 0, colorIndex: nextColorIndex,
        moving: false, isSettling: false
    };
    nextColorIndex = Math.floor(Math.random() * THEMES[currentTheme].colors.length);
}

function handleInput(e) {
    if (gameState !== STATES.PLAYING || (projectile && projectile.isSettling)) return;
    const rect = canvas.getBoundingClientRect();
    const x = ((e.clientX || (e.touches && e.touches[0].clientX)) - rect.left) * (canvas.width / rect.width);
    const y = ((e.clientY || (e.touches && e.touches[0].clientY)) - rect.top) * (canvas.height / rect.height);
    mouse.x = x; mouse.y = y;

    if ((e.type === 'pointerup' || e.type === 'touchend') && projectile && !projectile.moving) {
        const startX = canvas.width / 2, startY = canvas.height - bubbleRadius - 30;
        const angle = Math.atan2(y - startY, x - startX);
        if (angle < -0.2 && angle > -Math.PI + 0.2) {
            playSound('shoot'); 
            projectile.vx = Math.cos(angle) * 8.5; 
            projectile.vy = Math.sin(angle) * 8.5;
            projectile.moving = true;
        }
    }
}

window.onload = () => {
    resize();
    render();
    window.addEventListener('resize', () => { resize(); updateUI(); });
    canvas.addEventListener('pointerdown', handleInput);
    canvas.addEventListener('pointermove', handleInput);
    canvas.addEventListener('pointerup', handleInput);
};
</script>
</body>
</html>
